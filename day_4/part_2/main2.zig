const std = @import("std");
const print = std.debug.print;

// Lessons:
// Recursion is a fucking pain in the ass to debug and get right
// caching is really important

const DEBUG = true;

var gpa = std.heap.GeneralPurposeAllocator(.{}){};
const alloc = gpa.allocator();

//stores the number of copies a card generates in total
var copy_cache = std.AutoHashMap(usize, usize).init(alloc);

pub fn main() !void {
    const buf = @embedFile("input.txt");
    defer _ = gpa.deinit();
    var iter = std.mem.splitScalar(u8, buf, '\n');
    var match_map = std.ArrayList(usize).init(alloc);
    defer match_map.clearAndFree();
    defer copy_cache.clearAndFree();
    while (iter.next()) |line| {
        if (std.mem.eql(u8, line, "")) {
            break;
        }
        //match map is a list of cards winning numbers.
        //match_map[card_id - 1] == it's number of matches
        try match_map.append(try get_win_numbers(line));
        if (iter.peek() == null) {
            break;
        }
    }

    if (DEBUG) {
        for (1.., match_map.items) |i, e| {
            print("Matches for Card {d}: {d}\n", .{ i, e });
        }
    }
    var sum: usize = 0;

    // Main Loop
    for (0..match_map.items.len) |i| {
        sum += 1;
        const copies = try get_number_of_copies(i + 1, match_map, i);

        sum += copies;
        print("Running Sum: {d}\n", .{sum});
    }

    if (DEBUG) {
        var v_iter = copy_cache.valueIterator();
        var i: usize = 1;
        while (v_iter.next()) |value| {
            print("Copies generated by Card {d}: {d}\n", .{ i, value.* });
            i += 1;
        }
    }

    print("Final Sum: {d}\n", .{sum});
}

//return the number of matches in a line
fn get_win_numbers(line: []const u8) !usize {
    var sum: usize = 0;

    var iter = std.mem.tokenizeScalar(u8, line, ' ');

    var fst_section = true;

    var win_numbers = std.ArrayList(u8).init(alloc);
    var player_numbers = std.ArrayList(u8).init(alloc);
    defer win_numbers.clearAndFree();
    defer player_numbers.clearAndFree();

    while (iter.next()) |token| {
        if (std.mem.endsWith(u8, token, ":")) {
            continue;
        } else if (std.mem.eql(u8, token, "|")) {
            fst_section = false;
            continue;
        } else if (std.ascii.isDigit(token[0])) {
            if (fst_section) {
                const n = try std.fmt.parseInt(u8, token, 10);
                try win_numbers.append(n);
            } else {
                const n = try std.fmt.parseInt(u8, token, 10);
                try player_numbers.append(n);
            }
        }
        if (iter.peek() == null) {
            for (player_numbers.items) |p| {
                for (win_numbers.items) |w| {
                    if (p == w) {
                        sum += 1;
                        break;
                    }
                }
            }
            break;
        }
    }
    return sum;
}

fn get_number_of_copies(card_id: usize, matches: std.ArrayList(usize), index: usize) !usize {
    if (copy_cache.get(index)) |count| {
        return count;
    }
    const number_of_copies = matches.items[index];

    if (number_of_copies == 0) {
        return 0;
    }

    var i: usize = 1;
    var sum: usize = 0;
    while (i < number_of_copies + 1) : (i += 1) {
        sum += 1;
        sum += try get_number_of_copies(card_id, matches, index + i);
    }
    try copy_cache.put(index, sum);
    return sum;
}
